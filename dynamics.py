import numpy as np

def f(params, x, u, d=[0.]*3, g=9.81):

    """
    state:
        x = {x,y,z,q0,q1,q2,q3,xd,yd,zd,p ,q ,r ,w0,w1,w2,w3}
             0 1 2 3  4  5  6  7  8  9  10 11 12 13 14 15 16
    
    control:
        u = {w0d,w1d,w2d,w3d}
             0   1   2   3
    
    disturbance (simulated wind):
        d = {velW,qW0,qW1}
             0    1   2
    """

    # instantaneous thrusts and torques generated by the current w0...w3
    # x[13:17] = np.clip(x[13:17], params["minWmotor"], params["maxWmotor"]) # this clip shouldn't occur within the dynamics
    thrust = params['kTh'] * x[13:17] ** 2
    torque = params['kTo'] * x[13:17] ** 2

    # state derivates (from sympy.mechanics derivation)
    xd = np.stack(
        [
            x[7], x[8], x[9], # xd, yd, zd
            - 0.5 * x[10] * x[4] - 0.5 * x[11] * x[5] - 0.5 * x[6] * x[12], # q0d
              0.5 * x[10] * x[3] - 0.5 * x[11] * x[6] + 0.5 * x[5] * x[12], # q1d
              0.5 * x[10] * x[6] + 0.5 * x[11] * x[3] - 0.5 * x[4] * x[12], # q2d
            - 0.5 * x[10] * x[5] + 0.5 * x[11] * x[4] + 0.5 * x[3] * x[12], # q3d
            (
                params["Cd"]
                * np.sign(d[0] * np.cos(d[1]) * np.cos(d[2]) - x[7])
                * (d[0] * np.cos(d[1]) * np.cos(d[2]) - x[7]) ** 2
                - 2 * (x[3] * x[5] + x[4] * x[6]) * (thrust[0] + thrust[1] + thrust[2] + thrust[3])
            )
            / params["mB"], # xdd
            (
                params["Cd"]
                * np.sign(d[0] * np.sin(d[1]) * np.cos(d[2]) - x[8])
                * (d[0] * np.sin(d[1]) * np.cos(d[2]) - x[8]) ** 2
                + 2 * (x[3] * x[4] - x[5] * x[6]) * (thrust[0] + thrust[1] + thrust[2] + thrust[3])
            )
            / params["mB"], # ydd
            - (
                -params["Cd"] * np.sign(d[0] * np.sin(d[2]) + x[9]) * (d[0] * np.sin(d[2]) + x[9]) ** 2
                - (thrust[0] + thrust[1] + thrust[2] + thrust[3])
                * (x[3] ** 2 - x[4] ** 2 - x[5] ** 2 + x[6] ** 2)
                + g * params["mB"]
            )
            / params["mB"], # zdd (the - in front turns increased height to be positive - NEU)
            (
                (params["IB"][1,1] - params["IB"][2,2]) * x[11] * x[12]
                - params["usePrecession"] * params["IRzz"] * (x[13] - x[14] + x[15] - x[16]) * x[11]
                + (thrust[0] - thrust[1] - thrust[2] + thrust[3]) * params["dym"]
            )
            / params["IB"][0,0], # pd
            (
                (params["IB"][2,2] - params["IB"][0,0]) * x[10] * x[12]
                + params["usePrecession"] * params["IRzz"] * (x[13] - x[14] + x[15] - x[16]) * x[10]
                + (thrust[0] + thrust[1] - thrust[2] - thrust[3]) * params["dxm"]
            )
            / params["IB"][1,1], #qd
            ((params["IB"][0,0] - params["IB"][1,1]) * x[10] * x[11] - torque[0] + torque[1] - torque[2] + torque[3]) / params["IB"][2,2], # rd
            u[0] / params["IRzz"], u[1] / params["IRzz"], u[2] / params["IRzz"], u[3] / params["IRzz"] # w0d ... w3d
        ]
    )

    return xd

if __name__ == "__main__":

    from params import quad_params

    x = np.array([0,0,0,1,0,0,0,0,0,0,0,0,0,*[522.9847140714692]*4])
    u = np.array([0.01,-0.01,0.01,-0.01])

    xd = f(quad_params, x, u)

    print('fin')